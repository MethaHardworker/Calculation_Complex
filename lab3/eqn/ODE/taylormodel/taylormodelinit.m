function r = taylormodelinit(center,domain,order,monomial,coefficient,interval,type)
%TAYLORMODELININT   Initialization of a Taylor model
%
%  r = taylormodelinit(center,domain,order,monomial,coefficient,interval,type)
%
%  1) "center" = (x_c1,x_c2,...,x_cn) in R^n is the center point of the 
%     polynomial part p of the Taylor model r. Here p = p(x1,...,xn) 
%     is the multivariate polynomial in n unknowns x1,...,xn 
%     with monomials from "monomial" and corresponding coefficients in 
%     "coefficient", see 4), 5) below. For x=(x1,...,xn) in "domain", see 2), 
%     the value of r at x is defined by r(x):=p(x1-x_c1,....,xn-x_cn),
%     and the enclosure of r at y is defined by r(x)+"interval",
%     where "interval" is the error interval, see 6).
%
%  2) "domain" = D_1 x D_2 x ... x D_n \subsetq IR^n is the domain of 
%     r(x):=p(x1-x_c1,....,xn-x_cn),  
%     where D_j in IR is a closed interval with floating-point endpoints.
%
%  3) "order" is the maximum degree of the polynomial part p of r.
%
%  4) "monomial" \subset N^(kxn) is an exponent matrix. For i in {1,...,k}
%     monomial(i,:)=:alpha=(alpha_1,...,alpha_n) stands for the monomial
%     x^alpha := x1^alpha_1 * x2^alpha_2 *...* xn^alpha_n.
%
%  5) "coefficient" \subset F^(k) is the (column) vector of coefficients of  
%     the polynomial part p of r, see 1). 
%     For i in {1,...,k}, alpha_i:=monomial(i,:), and c_i := coefficient(i) 
%     we have p(x) = sum_{i=1}^k c_i * x^alpha_i.
%
%  6) "interval" =: I in IR is the error interval of the Taylor model r which
%     covers all rounding errors. For x in "domain", r(x) + I = p(x-center) + I  
%     gives the verified enclosure of r at y.
%
%  7) "type" = 0: general (default) 
%              1: ODE 
%     ODE-type Taylor models r for solving initial value problems generated by 
%     the function "verifyode" have a special form. Precisely, they have  
%     a domain [-1,1]^(n-1) x [t,t+h], and center point (0,...,0,t),
%     where n =: a.dim. The final n-th domain [t,t+h] is the time domain of 
%     width h>0 and some starting time t. 
%     This special form indicated by "type = 1" is used to compute the Taylor
%     model image component more efficiently than for general Taylor models 
%     with arbitrary domains. The latter get the default "type" = 0.   
%       
% To initialize an MxN-matrix T with M*N > 1 such that each T(i,j) is a 
% Taylor model, the input parameters "center", "domain", "monomial", and 
% "coefficient" must be cell arrays of size MxN so that, for example, 
% domain{2,1} contains the domain of the Taylor model T(2,1). 
% Likewise, monomial{2,1} contains the monomial matrix of T(2,1). 
% The input parameters "order", "interval", and "type" must be MxN-matrices.
% Thus, for example, interval(2,1) contains the error interval of T(2,1)
% In particular, this means that the input parameter "interval"
% must be transferred as an MxN-interval-matrix.

% written  08/20/15     F. Buenger
% modified 11/20/15     F. Buenger  Initialization of matrices of Taylor models
% modified 12/08/15     F. Buenger  new component type
% modified 02/10/16     F. Buenger  "intval"-components --> intval-like structures  
% modified 05/17/17     F. Buenger  new global constant INTLAB_ODE_VARS.SPARSE   

global INTLAB_ODE_VARS    % global parameters 
global INTLAB_ODE_OPTIONS % global options  
global INTLAB_ODE_TCOEFF  % global constant factors for certain Taylor series

if nargin == 0    % taylormodelinit should only be called by the function starintlab.m,  
                  % in order to initialize the subsequent global variables once.                  
    INTLAB_ODE_OPTIONS = [];              
    s.inf = [];
    s.sup = [];
    INTLAB_ODE_VARS.EMPTYIV = s; % empty interval structure, used for INTLAB_ODE_VARS.ODEMODE == 0 (nonverified computation)
    s.inf = 0;
    s.sup = 0;    
    INTLAB_ODE_VARS.ZEROIV = s; % zero interval structure
    INTLAB_ODE_VARS.ZEROTAYLORMODEL = taylormodelinit(0,s,1,0,0,s,1); % initial/zero Taylor model for preallocation and other dummy purposes                                                                    
    INTLAB_ODE_VARS.ODEMODE = 1;
    % 1: verified computation in Taylor model arithmetic
    % 0: non-verified computation in Taylor model arithmetic
    %    In particular, error intervals and images are not computed and set to INTLAB_ODE_VARS.EMPTYIV.
    %    This compares to NO_REMAINDER in Riot, see [E], Section 4.4.3.2, p.112-113, and code on p.121 for description.
    
    INTLAB_ODE_VARS.RECMODE = 0;  % The record mode controls the so called "record feature",
    % see [E], section 4.4.3.1, p.112, and code on p.120-127 for description.
    % Three values are distinguished:
    %   0 : Record feature off (default). This compares to NORMAL_MODE in Riot, see [E], p.121,127.
    %   1 : Record feature on, write mode. This compares to REMAINDER_REC in Riot, see [E], p.122.
    %   2 : Record feature on, read mode. This compares to REMAINDER_PLAY in Riot, see [E], p.123,126.
    
    
    INTLAB_ODE_VARS.SPARSE = false;           
    % Switch between using the MATLAB function
    % "conv", which only accepts non-sparse input (SPARSE = false), and the private  
    % function "sconv", which can have sparse or non-sparse input (SPARSE = true).
    % The default is SPARSE = false. 
    % The convolution is used, for example, for multiplication (function "times") and squaring (function "sqr").
    
    % Initialization of the global variable INTLAB_ODE_TCOEFF which will store some constant
    % factors for Taylor expansions of certain standard functions like exp and sqrt. 
    % (They only depend on the order n of the Taylor expansion.)
    INTLAB_ODE_TCOEFF.INVFACT_FLP = [];  % inverse factorial 1/factorial(0:n+1) for non-verified floating-point computations          
    INTLAB_ODE_TCOEFF.INVFACT_IV = [];   % inverse factorial 1/intval(factorial(0:n+1)) for verified computations    
    INTLAB_ODE_TCOEFF.SQRT_FLP = [];     % factors for Taylor expansion of sqrt for non-verified floating-point computations  
    INTLAB_ODE_TCOEFF.SQRT_IV = [];      % factors for Taylor expansion of sqrt for verified computations
    
    t_wait = 5;       % Wait 10 seconds until a progress window is displayed.     
    progress(t_wait); % This default value can be changed freely by calling progress(t_wait_new)
                      % with some different value, say t_wait_new = 10.  
    return;
end
  
if nargin < 5 
    error('invalid call of constructor taylormodel: wrong number of input parameters')
end
if nargin <= 5 || isempty(interval)
   interval.inf = zeros(size(order));
   interval.sup = interval.inf;
end
if nargin <= 6 || isempty(type)
    type = zeros(size(order));
end

% Check number of dimensions. Maximally 2 dimensions, i.e. matrices, are allowed for Taylor models.
L = [ length(size(center));
      length(size(domain));
      length(size(order));
      length(size(monomial));
      length(size(coefficient));
      length(size(interval));
      length(size(type));
    ];
 
if max(L) > 2
    error('maximally two dimensions for type taylormodel')
end
  
% Check if a single Taylor model or a nontrivial matrix of Taylor models shall be initialized.
C = [isa(center,'cell');
     isa(domain,'cell');
     isa(monomial,'cell');
     isa(coefficient,'cell');
    ];

init_mat = max(C); 
if min(C) ~= init_mat
    error('inconsistent input!') 
end

% The two cases 
%
%   A) initialize a single Taylor model [(1x1)-matrix], init_mat = 0
%   B) initialize a nontrivial matrix of Taylor models [(mxn)-matrix], init_mat = 1 
%
% shall be treated uniformly. Therefore, in case A) the input parameters 
% 'center', 'domain', 'monomial', 'coefficient' are encapsulated in cell arrays. 
if ~init_mat
  center = {center};
  domain = {domain};
  monomial = {monomial};
  coefficient = {coefficient};
end

S = [size(center);
     size(domain);
     size(order);
     size(monomial);
     size(coefficient);
     size(interval.inf);
     size(type);
    ];
% Check if all parameters have the same matrix size (m,n).
m = max(S(:,1));
n = max(S(:,2));
if m > min(S(:,1)) || n > min(S(:,2))
  error('Parameter sizes are inconsistent!') 
end
% Create initial pattern for type taylormodel.
dummy = struct('dim',[],...
               'center',[],...
               'domain',[],...
               'order',[],...
               'monomial',[],...
               'coefficient',[],...
               'interval',[],...
               'type',[],...
               'image',INTLAB_ODE_VARS.ZEROIV); 
r = repmat(dummy,m,n); % Create empty (m,n)-matrix which finally shall contain the Taylor models. 

% Initialize each Taylor model component individually.
%
% Remark: The main application of Taylor models is solving small(!) 
%   ODE-systems, i.e., differential systems with, in general, less 
%   than 10 equations. Therefore, we do not care so much to run "for-loops" 
%   over supposedly small m,n < 10.
%   The (fast) vectorization is done 'inside' each single Taylor model 
%   component which, for example, represents a 'Taylor polynomial inclusion'  
%   of a component function of the solution of the ODE-system.

for i = 1:m
    for j = 1:n    
        center_ = center{i,j};
        domain_ = domain{i,j};
        order_ = order(i,j);
        monomial_ = monomial{i,j};
        coefficient_ = coefficient{i,j};
        interval_.inf = interval.inf(i,j);
        interval_.sup = interval.sup(i,j);        
        type_ = type(i,j);
        
        % check Taylor model type
        if type_ ~= 0 && type_ ~= 1
            error('Unknown Taylor model type.');            
        end
        
        % check center_
        if ~isfloat(center_)
            error('center must be of type float.')
        end
        s = size(center_);
        if s(1) ~= 1 && s(2) ~= 1
            error('center must be a nonempty vector.')
        end
        if s(1) == 1
            center_ = center_'; % Convert center_ to column vector if input was a row vector.
        end        
        d = length(center_); % dimension of domain
%         if (any(center_(1:d-1)) || center_(d) < 0) && type_ == 1
%             % center_ must have the form (0,...,0,t) with t>=0 for ODE - Taylor models of type 1.
%             error('Wrong center point center for ODE - Taylor models of type 1.')
%         end

        if any(center_(1:d-1)) && type_ == 1
            % center_ must have the form (0,...,0,t) with t>=0 for ODE - Taylor models of type 1.
            error('Wrong center point center for ODE - Taylor models of type 1.')
        end        

        % check domain        
        if ~isiv(domain_)
            error('"domain" must be an interval-like structure.')
        end
        s = size(domain_.inf);
        if s(1) == 1
            domain_.inf = domain_.inf'; % Convert domain to column vector if input was a row vector.
            domain_.sup = domain_.sup';
        end
        if d ~= length(domain_.inf)
            error('Lengths of center and domain do not fit.');
        end
%         if type_ == 1 && ( any(domain_.inf(1:d-1) ~= -1) || any(domain_.sup(1:d-1) ~= 1) || domain_.inf(d) < 0 ) 
%             % domain must have the form [-1,1]^(d-1) x [t,t+h] with t,h>=0 for ODE - Taylor models of type 1.
%             error('Wrong domain for ODE - Taylor models of type 1.')
%         end
        if type_ == 1 && ( any(domain_.inf(1:d-1) ~= -1) || any(domain_.sup(1:d-1) ~= 1) || domain_.inf(d) > domain_.sup(d) ) 
            % domain must have the form [-1,1]^(d-1) x [t,t+h] with h>=0 for ODE - Taylor models of type 1.
            error('Wrong domain for ODE - Taylor models of type 1.')
        end        
        
        % check order
        if ~(isfloat(order_) && isreal(order_))  || round(order_) ~= order_ || order_ < 1
            error('order must be a positive integer.') 
        end
        
        % check monomial
        if isempty(monomial_)
            monomial_ = zeros(1,m);
        end
        if ~(isfloat(monomial_) && isreal(monomial_)) || any( round(monomial_(:)) ~= monomial_(:) ) || min(monomial_(:)) < 0 
            % simple test, if monomial entries (which are exponents) are nonnegative integers
            error('monomial entries must be nonnegative integers.')
        end
        s = size(monomial_);
        if d ~= s(2)
            error('dimensions of center and monomial are not consistent.');
        end
        l = s(1); % degrees of monomials
        if max(sum(monomial_,2)) > order_
            error('Some monomials have larger order than specified.');
        end
                
        % check coefficients
        if isempty(coefficient_)
            coefficient_ = 0;
        end
        if ~(isfloat(coefficient_) && isreal(coefficient_) )
            error('invalid call of constructor taylormodel: coefficient entries must be of type float')
        end
        s = size(coefficient_);
        if s(1) ~= 1 && s(2) ~= 1
            error('coeffient must be a vector.');
        end
        if s(2) > 1
            coefficient_ = coefficient_'; % conversion to column vector
            s = size(coefficient_);
        end        
        if s(1) ~= l
            error('Number of monomials and coefficients are not equal.');
        end
                
        % check interval
        if ~isiv(interval_)
            error('"interval" must be an intval-like structure.');
        end
        if numel(interval_.inf) > 1 || numel(interval_.sup) > 1
            error('too many "interval" entries');
        end

        % initialize
        r(i,j).center = center_;
        r(i,j).domain = domain_;
        r(i,j).order = order_;
        r(i,j).monomial = monomial_;
        r(i,j).coefficient = coefficient_;
        r(i,j).dim = d;
        r(i,j).interval = interval_;    
        r(i,j).type = type_;      
        
    end % j
end % i
r = taylormodel( r , 'taylormodelinit' );

end % function taylormodelinit